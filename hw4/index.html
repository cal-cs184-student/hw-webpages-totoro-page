<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 4 Write-Up</h1>
		<div style="text-align: center;">Names: Annabel Ng (3038330323) and Henry Ko (3034941989)</div>

		<br>

		Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-totoro-page/hw4/index.html">cal-cs184-student.github.io/hw-webpages-totoro-page/hw4</a>

		<br>

		Link to GitHub repository: <a href="https://github.com/cal-cs184-student/sp25-hw4-totoro-4">github.com/cal-cs184-student/sp25-hw4-totoro-4/</a>

		<figure>
			<img src="sphere_drape_fast.gif" alt="Cloth draped over sphere" style="width: 25%"/>
			<figcaption>The star cloth and sphere of this homework!</figcaption>
		</figure>

		<!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>

		In this homework, we explored how to develop a cloth model for simulation from the ground up. This involved figuring out how to represent the cloth itself and how to simulate its motion and behavior under physical parameters. We also explored how to handle collisions with other objects and self-collisions, as well as how to enhance the visual representation of the cloth using shaders. Overall, this homework was a great introduction to simulation, and we realized how even the most simple motions, like a cloth falling onto a sphere, involves a lot of different components and considerations in order to make it look physically realistic. 
		<br><br>
		We started with first implementing a simple grid of masses and springs to create a wireframe representation of cloth. This was surprisingly more involved than we thought at first glance, since there were three different types of constraints and conditions we had to account for, including shearing, structural and bending constraints. In addition, we originally tried to add the springs alongside point masses into the grid, but this messed up our indexing and led to a lot of confusion, so we ended up adding the springs after we had all the point masses in place. 
		<br><br>
		We then implemented numerical integration to simulate the cloth's motion and behavior under various physical parameters like spring constant, density, and damping. We looked at external forces like gravity and spring correction forces which keep the cloth together. We computed the total force acting on each point mass based on these external and spring forces with Hooke's Law and applied Verlet integration to update the positions of the point masses over time. We also corrected the point mass positions to prevent unreasonable spring defromation. This part was mostly straightforward: we just had to make sure we were very careful with the order we were updating the positions and velocities of the point masses.
		<br><br>
		Next, we handled collisions with other objects like spheres and planes and the cloth itself, and observed how changing the different parameters created different simulations of collisions. We first checked to see if a pointmass would intersect or lay inside the sphere, then calculate the tangent point on the surface, and figure out how to correct the point mass position to bump it to the tangent point. For computing intersections with planes, we had to check if the point mass was below the plane's height (with a dot product instead of the Euclidean norm like in sphere collision) and adjust its position accordingly. We had to make sure we were accounting for the surface offset when computing the tangent point, and followed the same steps of bumping it back up to the surface of the plane. 
		<br><br>
		Implementing self collision was probably the most complicated out of the three collision types since there were a lot of moving parts involved. We implemented a few helpers to first compute a hash key based on the point mass 3D position and converting the point mass position into membership in some 3D box volume. We used these hash positions to build a spatial map of the point masses, and then iterated through each point mass to check for collisions with other point masses in the same spatial map cell. We computed the correction vector necessary to set the pairwise distance between colliding point masses to be equal to twice the thickness of the cloth, and averaged out the corrections to apply to each point mass by the number of corrections and the simulation steps. Implementing this logic took quite a bit of time and thought since we had to properly initialize the spatial map in order to check for collisions correctly, and also to ensure that we were only checking for collisions with other point masses that were not the same as the current one. We also had to be careful with how we applied the corrections to avoid infinite loops of self-collisions. 
		<br><br>
		Finally, we explored developing vertex and fragment shaders in <code>GLSL</code> to enhance the visual representation of our cloth. We implemented diffuse shading, Blinn-Phong shading, texture mapping, displacement / bump mapping, and mirror reflections. We also struggled with some of the shader logic, especially with getting the normals and light direction right for the mirror model and displacement model, which involved a lot of staring at the code and debugging. We ran into a major bug for our displacement code where the displacement was not working correctly on the sphere and it looked too smooth, and it took us a while to realize that we were not properly transforming the position into world space. Shoutout to the student on Ed for helping us to figure it out! Overall, this part was a great introduction to shaders and how they can be used to create more realistic visual effects in computer graphics.

		<h2>Part 1: Masses and springs</h2>
		We built out our grid of masses and springs to create our cloth wireframe. 

		<br><br>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="t1_all.png" width="400px"/>
				  <figcaption>View of wireframe with all constraints</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="task1_springs.png" width="400px"/>
				  <figcaption>Another view of wireframe with all constraints</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="t1_no_shearing.png" width="400px"/>
				  <figcaption>Wireframe with NO shearing constraints</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="t1_only_shearing.png" width="400px"/>
				  <figcaption>Wireframe with ONLY shearing constraitns</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h2>Part 2: Simulation via numerical integration</h2>
		<i>Experiment with some the parameters in the simulation. To do so, pause the simulation at the start with P, modify the values of interest, and then resume by pressing P again. You can also restart the simulation at any time from the cloth’s starting position by pressing R.</i>

		<br><br>

		<i>Describe the effects of:</i>
		<li><i>Changing the spring constant <code>ks</code>; how does the cloth behave from start to rest with a very low <code>ks</code>? A high <code>ks</code>?</i> <br><br>When there's a very low <code>ks=500</code>, the cloth seems a lot more soft and flexible with a deeper drape and it has more motion as it's falling as well. When there's a very high <code>ks=50000</code>, the cloth seems extremely stiff and barely creases in on itself and has a very small drape as well. It just seems to be made of a much thicker material that doesn't fold as easily.  </li>

		<br>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
				<tr>
					<th>ks = 500</th>
					<th>ks = 500</th>
					<th>ks = 50000</th>
					<th>ks = 50000</th>
				</tr>
				<tr>
					<td>
						<img src="ks_500_mid.png" width="200px" alt="ks 500 mid"/>
						<figcaption>Mid-fall</figcaption>
					</td>
					<td>
						<img src="ks_500.png" width="200px" alt="ks 500"/>
						<figcaption>Resting state</figcaption>
					</td>
					<td>
						<img src="ks_50000_mid.png" width="200px" alt="ks 50000 mid"/>
						<figcaption>Mid-fall</figcaption>
					</td>
					<td>
						<img src="ks_50000.png" width="200px" alt="ks 50000"/>
						<figcaption>Resting state</figcaption>
					</td>
				</tr>
			</table>
		</div>
<br><br>
		<li><i>What about for <code>density</code>?</i> 
			<br><br>
			When the density is low(density=1), the cloth gives the impression that its light-weight as it's seen be being less droopy in its resting state.
			However, when the density is set to a high value(density=10,000), the cloth feels heavy as it can be seen with a large droop in its final resting state.
			<br>
			<br></li>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
				<tr>
					<th>density = 1</th>
					<th>density = 1</th>
					<th>density = 10,000</th>
					<th>density = 10,000</th>
				</tr>
				<tr>
					<td>
						<img src="density=1_init.png" width="200px" alt="density 1 mid"/>
						<figcaption>Mid-fall</figcaption>
					</td>
					<td>
						<img src="density=1_final.png" width="200px" alt="density 1 final"/>
						<figcaption>Resting state</figcaption>
					</td>
					<td>
						<img src="density=10000_init.png" width="200px" alt="density 10000 mid"/>
						<figcaption>Mid-fall</figcaption>
					</td>
					<td>
						<img src="density=10000_final.png" width="200px" alt="density 10000 final"/>
						<figcaption>Resting state</figcaption>
					</td>
				</tr>
			</table>
		</div>
<br><br>
		<li><i>What about for <code>damping</code>?</i>
		<br><br> When the damping percentage is low(0.10), the cloth drops quickly with little resistance, but when 
		the damping percentage is high(0.90), the cloth falls slowly and gradually.
		<br><br>
	</li>
	<div style="display: flex; flex-direction: column; align-items: center;">
		<table style="width: 100%; text-align: center; border-collapse: collapse;">
			<tr>
				<th>damping = 0.10</th>
				<th>damping = 0.10</th>
				<th>damping = 0.90</th>
				<th>damping = 0.90</th>
			</tr>
			<tr>
				<td>
					<img src="damping=0.10_init.png" width="200px" alt="damping .10 mid"/>
					<figcaption>Mid-fall</figcaption>
				</td>
				<td>
					<img src="damping=0.10_final.png" width="200px" alt="damping .10 final"/>
					<figcaption>Resting state</figcaption>
				</td>
				<td>
					<img src="damping=0.90_init.png" width="200px" alt="damping .90 mid"/>
					<figcaption>Mid-fall</figcaption>
				</td>
				<td>
					<img src="damping=0.90_final.png" width="200px" alt="damping .90 final"/>
					<figcaption>Resting state</figcaption>
				</td>
			</tr>
		</table>
	</div>
	
		
		<i>For each of the above, observe any noticeable differences in the cloth compared to the default parameters and show us some screenshots of those interesting differences and describe when they occur.</i>
		<ul>1. Spring Constant(ks)</ul>
		Compared to the default state, there's a noticeable difference when theres a very high spring constant. For example, below is a comparison between default(ks=5,000) and a high spring constant(ks=50,000).
		We can see that the cloth looks noticeably more stiff with a high spring constant. 
		<br><br>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
				<tr>
					<td>
						<img src="resting_cloth.png" width=72% alt="damping .10 mid"/>
						<figcaption>ks = 5,000 (default)</figcaption>
					</td>
					<td>
						<img src="ks_50000.png" width=75% alt="damping .10 final"/>
						<figcaption>ks = 50,000</figcaption>
					</td>
				</tr>
			</table>
		</div>
<br>
<ul>2. Density</ul>
For density, we can see a noticeable difference in the perceived weight of a cloth when density is high. 
Compared to the default value of density of 15, when there's a density of 10,000 the final resting state of the cloth looks heavy. 
<br><br>
<div style="display: flex; flex-direction: column; align-items: center;">
	<table style="width: 100%; text-align: center; border-collapse: collapse;">
		<tr>
			<td>
				<img src="resting_cloth.png" width=70% alt="damping .10 mid"/>
				<figcaption>density = 15 (default)</figcaption>
			</td>
			<td>
				<img src="density=10000_final.png" width=95% alt="damping .10 final"/>
				<figcaption>density = 10,000</figcaption>
			</td>
		</tr>
	</table>
</div>
<br>
<ul>3. Damping</ul>
The visual differences between final states of different damping values are hard to tell, but the difference lies in
how fast the cloth reaches the final resting state. The higher damping percentage is, the longer it takes for it to reach its resting state. 
<br><br>
<div style="display: flex; flex-direction: column; align-items: center;">
	<table style="width: 100%; text-align: center; border-collapse: collapse;">
		<tr>
			<td>
				<img src="resting_cloth.png" width=65% alt="damping .10 mid"/>
				<figcaption>damping = 0.20 (default)</figcaption>
			</td>
			<td>
				<img src="damping=0.90_final.png" width=90% alt="damping .10 final"/>
				<figcaption>damping = 0.90</figcaption>
			</td>
		</tr>
	</table>
</div>

		<br><br>

		<i>Show us a screenshot of your shaded cloth from scene/pinned4.json in its final resting state! If you choose to use different parameters than the default ones, please list them.</i>
		<br><br>
		<div style="text-align: center;">
			<img src="resting_cloth.png" width="60%" alt="Pinned cloth resting state with default parameters"/>
			<figcaption>Pinned cloth resting state with default parameters</figcaption>
		</div>


		<h2>Part 3: Handling collisions with other objects</h2>
		<i>Describe your implementation of handling collisions with spheres and planes.</i>
		<br><br>
		For handling collisions with spheres, we code up the <code>Sphere:Collide</code> function to first calculate the distance between the given <code>PointMass</code> position and the sphere's center by subtracting the sphere's center from the <code>PointMass</code> position and taking the norm as the distance. If the computed distance is less than the sphere's radius, this indicates that the <code>PointMass</code> lies inside the sphere's radius. Since we only care about the <code>PointMass</code> that lie inside the sphere's radius, we then compute the tangent point on the surface of the sphere by adding the unit direction between the sphere and the <code>PointMass</code> scaled by the size of the radius.  Once we have this tangent point, we calculate the correction vector as the difference between this tangent point and the last position of the <code>PointMass</code>. We then apply this correction vector to the <code>PointMass</code> position by setting the position to be the last position plus the correction vector multiplied by <code>(1-friction)</code> to account for the friction of the collision, essentially bumping up the position of the <code>PointMass</code> up to the surface of the sphere. 

		<br><br>

		For handling collisions with planes, we code up the <code>Plane:Collide</code> function to check if the <code>PointMass</code> is below the plane's height by taking the difference between the <code>PointMass</code>'s position and the plane's given point, and checking if the dot product of this difference with the plane's normal is less than the <code>SURFACE_OFFSET</code>. If it's less than the offset, this indicates that the <code>PointMass</code> is below the plane's height and we need to adjust it. To do this correction, we compute the tangent point on the plane by subtracting the normal direction of the plane, scaled by the distance to the plane adjusted by the offset, from the <code>PointMass</code>'s position. Similar to the sphere collision, we calculate the correction vector as the difference between the tangent point and the <code>PointMass</code>'s last position. We then apply this correction vector to the <code>PointMass</code> position by setting the position to be the last position plus the correction vector multiplied by <code>(1-friction)</code> to account for friction of the collision.
		<br><br>
		
		In addition, we also modify the <code>Cloth::Collide</code> code to iterate through all the <code>PointMass</code> object, and in each iteration, we iterate through every <code>CollisionObject</code> and check for collisions with the <code>PointMass</code> object.

		<br><br>
		<i>Show us screenshots of your shaded cloth from scene/sphere.json in its final resting state on the sphere using the default ks = 5000 as well as with ks = 500 and ks = 50000. Describe the differences in the results.</i>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
				<tr>
					<td>
						<img src="sphere_500.png" width=90% alt="Sphere ks 500"/>
						<figcaption>ks = 500</figcaption>
					</td>
					<td>
						<img src="sphere_5000.png" width=90% alt="Sphere ks 5000"/>
						<figcaption>ks = 5000</figcaption>
					</td>
					<td>
						<img src="sphere_50000.png" width=90% alt="Sphere ks 50000"/>
						<figcaption>ks = 50000</figcaption>
					</td>
				</tr>
			</table>
		</div>

		<br>
		As the ks increases, the cloth seems to be much more stiff and rigid and less likely to drape softly over the sphere. The cloth with <code>ks = 500</code> is much more flexible and drapes over the sphere more naturally and molds over the sphere like a very thin flexible cloth, while the cloth with <code>ks = 50000</code> is very stiff and doesn't mold to the sphere's shape as much and appears to extrude out more. The cloth with <code>ks = 5000</code> is somewhere in between, with a moderate amount of drape and stiffness.

		<br><br>

		<i>Show us a screenshot of your shaded cloth lying peacefully at rest on the plane.</i>


		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
				<tr>
					<td>
						<img src="plane.png" width=80% alt="Sphere ks 500"/>
						<figcaption>Cloth at rest on plane</figcaption>
					</td>
					<td>
						<img src="plane_wire.png" width=80% alt="Sphere ks 5000"/>
						<figcaption>Zoom of cloth wireframe at rest on plane</figcaption>
					</td>
				</tr>
			</table>
		</div>

		<h2>Part 4: Handling self-collisions</h2>
		<i>Describe your implementation of handling self-collisions.</i>
		<br><br>
		To handle self-collision, we first write a helper function <code>Cloth::hash_position</code> which hashes a given 3D position into a unique float based on membership in a 3D boxes with dimensions <code>w = 3 * width / num_width_points</code>, <code>h = 3 * height / num_height_points</code>, and <code>t = std::max(w, h)</code>. We then "snap" the pointmass to the nearest box by taking the <code>fmod</code> of the position's x, y, and z coordinates with respect to the box dimensions and subtracting the <code>fmod</code> value from the position coordinate to get the box coordinates. We then combine these box coordinates into a unique float hash value by setting the <code>hash = snapped_x + width * (snapped_y + height * snapped_z)</code>

		<br><br>

		Next, we wrote a function to actually build the spatial map out of all the point masses by iterating through each point mass, computing the hash based on the point mass position, checking if the hash is already in the spatial map, and if not, adding it to the spatial map. 
		<br><br>

		Then, we wrote the <code>Cloth::self_collide</code> function to iterate through all the point masses, check for collisions with other point masses in the same spatial map cell, and determine the average correction amount. We first calculate the hash of that position and check if there are any other point masses in the same cell. We initialize a <code>total_correction</code> vector and a corrections counter, and iterate through each candidate point mass and check if the candidate is not the same as the current point mass. If they are not the same, we calculate the distance <code>dist</code> between the given point mass and the candidate by subtracting their positions and taking the norm. If the distance apart is less than <code>2*thickness</code>, we want to find the correction vector necessary to set the pairwise distance to be <b>equal</b> to <code>2*thickness</code> apart. We do this by taking the unit direction between the two point masses, and scaling this direction by <code>2*thickness - dist</code>, which becomes our <code>curr_correction</code> vector. We then add this correction vector to our <code>total_correction</code> vector and increment our corrections counter. After iterating through all the candidates, we  check if there are any corrections, and if there are, we divide the <code>total_correction</code> vector by the corrections counter and simulation steps and apply this average correction to the current point mass's position by incrementing the position by the average correction vector.
		
		
		<br><br>
		Lastly, we modified the <code>PointMass::Collide</code> function to check for self-collisions by building the spatial map, and then iterating through the all of the point masses and calling <code>self_collide</code> to check for self collision. 

		<br><br>
		<i>Show us at least 3 screenshots that document how your cloth falls and folds on itself, starting with an early, initial self-collision and ending with the cloth at a more restful state (even if it is still slightly bouncy on the ground).</i>
		<br><br>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
				<tr>
					<td style="width: 25%; padding-right: 10px;">
						<img src="self_1.png" width="100%" alt="Initial Self-Collision" style="object-fit: cover; height: 200px;"/>
						<figcaption>Initial Self-Collision</figcaption>
					</td>
					<td style="width: 25%; padding-right: 10px;">
						<img src="self_2.png" width="100%" alt="Intermediate State" style="object-fit: cover; height: 200px;"/>
						<figcaption>Intermediate State</figcaption>
					</td>
					<td style="width: 25%; padding-right: 10px;">
						<img src="self_3.png" width="100%" alt="Further Folding" style="object-fit: cover; height: 200px;"/>
						<figcaption>Further Folding</figcaption>
					</td>
					<td style="width: 25%;">
						<img src="self_4.png" width="100%" alt="Resting State" style="object-fit: cover; height: 200px;"/>
						<figcaption>Resting State</figcaption>
					</td>
				</tr>
			</table>
		</div>

		<br><br>
		<i>Vary the density as well as ks and describe with words and screenshots how they affect the behavior of the cloth as it falls on itself.</i>
<br><br>
On a high level, density controls how fast the cloth falls along with how many small creases there are. A more dense cloth will fall faster and will yield a higher number
of smaller folds(i.e. higher tendency of self collisions). Meanwhile, ks will control how stiff the cloth is to folding. A higher ks value will result the cloth
resisting to having many folds.
<br><br>
Below is a chart of varying density and ks. We can see that a low density and low ks(lower-left) results in a light-weight cloth that folds well. But if we 
increase the ks value to 9,000(upper-left), we can see the cloth is "resisting" folds, hence resulting in only a few large folds.
On the other side of the spectrum we can see that a high density and high ks(upper-right), will result in a cloth that is heavy(i.e. falling fast) and more rigid.

<div style="display: flex; flex-direction: column; align-items: center;">
	<table style="border-collapse: separate; text-align: center; border-spacing: 10px">
		<tr>
			<td rowspan="4" style="writing-mode: vertical-rl; transform: rotate(180deg); padding: 10px; font-weight: bold;">Increasing ks →</td>
			<td></td>
			<td style="padding: 5px; font-weight: bold;">density = 1</td>
			<td style="padding: 5px; font-weight: bold;">density = 15</td>
			<td style="padding: 5px; font-weight: bold;">density = 50</td>
		</tr>
		<tr>
			<td style="font-weight: bold;">ks = 9,000</td>
			<td>
				<img src="d1_ks9000.png" width="200px" alt="density 1 ks 9000"/>
				<figcaption>density=1, ks=9,000</figcaption>
			</td>
			<td>
				<img src="d15_ks9000.png" width="200px" alt="density 15 ks 9000"/>
				<figcaption>density=15, ks=9,000</figcaption>
			</td>
			<td>
				<img src="d50_ks9000.png" width="200px" alt="density 50 ks 9000"/>
				<figcaption>density=50, ks=9,000</figcaption>
			</td>
		</tr>
		<tr>
			<td style="font-weight: bold;">ks = 5,000</td>
			<td>
				<img src="d1_ks5000.png" width="200px" alt="density 1 ks 5000"/>
				<figcaption>density=1, ks=5,000</figcaption>
			</td>
			<td>
				<img src="d15_ks5000.png" width="200px" alt="density 15 ks 5000"/>
				<figcaption>density=15, ks=5,000</figcaption>
			</td>
			<td>
				<img src="d50_ks5000.png" width="200px" alt="density 50 ks 5000"/>
				<figcaption>density=50, ks=5,000</figcaption>
			</td>
		</tr>
		<tr>
			<td style="font-weight: bold;">ks = 1,000</td>
			<td>
				<img src="d1_ks1000.png" width="200px" alt="density 1 ks 1000"/>
				<figcaption>density=1, ks=1,000</figcaption>
			</td>
			<td>
				<img src="d15_ks1000.png" width="200px" alt="density 15 ks 1000"/>
				<figcaption>density=15, ks=1,000</figcaption>
			</td>
			<td>
				<img src="d50_ks1000.png" width="200px" alt="density 50 ks 1000"/>
				<figcaption>density=50, ks=1,000</figcaption>
			</td>
		</tr>
	</table>
</div>



		<h2>Part 5: Shaders</h2>
		<i>Explain in your own words what is a shader program and how vertex and fragment shaders work together to create lighting and material effects.</i>
<br><br>
A shader program is a specialized program made to run on the GPU in parallel. The main purpose is to compute how geometry is rendered on the screen quickly.
There are two parts to a shader--the vertex shader and fragment shader. The vertex shader transforms the 3D positions of each vertex on the mesh from model space
into screen space using transformation matrices. It also passes information like normals or positions as output. The outputs of the vertex shader are used as
inputs to the fragment shader where it runs for each pixel that is part of the final rendered triangle. It is reponsible for getting the right
lighting, color, and texture, which is why its result is "out_color" that determines the final color on our screen.

		<br><br>

		<i>Explain the Blinn-Phong shading model in your own words. Show a screenshot of your Blinn-Phong shader outputting only the ambient component, a screen shot only outputting the diffuse component, a screen shot only outputting the specular component, and one using the entire Blinn-Phong model.</i>
<br><br>
The Blinn-Phong shading model combines ambient light component, diffuse light component, and specular light component to get the final light or color value. The ambient light can be seen
as the default level of light there is and is set to a small constant value. We used a ambient light value of 0.1 to ensure that it's not zero, but very small so that it does not
interfere too much with diffuse light and specular light. Next, diffuse light is essentially how much light hits the surface since it's the dot product between the normal vector to the surface
and light direction. This means that diffuse light is strongest when the light source is directly facing the surface. Finally, the specular light component is responsible for determining how "shiny"
the surface is, such as a metallic surface. And together, all-combined, we get the final Blinn-Phong shading model.
<br>

<div style="display: flex; flex-direction: column; align-items: center;">
    <table style="width: 100%; text-align: center; border-collapse: separate; border-spacing: 15px;">
      <tr>
        <td style="text-align: center; padding: 10px;">
          <img src="phong_ambient_only.png" width="400px"/>
          <figcaption>Only Ambient</figcaption>
        </td>
        <td style="text-align: center; padding: 10px;">
          <img src="phong_diffuse_only.png" width="400px"/>
          <figcaption>Only Diffuse</figcaption>
        </td>
      </tr>
      <tr>
        <td style="text-align: center; padding: 10px;">
          <img src="phong_specular_only.png" width="400px"/>
          <figcaption>Only Specular</figcaption>
        </td>
        <td style="text-align: center; padding: 10px;">
          <img src="phong_total.png" width="400px"/>
          <figcaption>All combined</figcaption>
        </td>
      </tr>
    </table>
</div>

<!-- <table style="width: 100%; text-align: center; border-collapse: collapse; margin-top: 20px;">
	<tr>
		<td>
			<img src="phong_ambient_only.png" width="400px" alt="Ambient Only"/>
			<figcaption>Only Ambient</figcaption>
		</td>
		<td>
			<img src="phong_diffuse_only.png" width="400px" alt="Diffuse Only"/>
			<figcaption>Only Diffuse</figcaption>
		</td>
	</tr>
	<tr>
		<td>
			<img src="phong_specular_only.png" width="400px" alt="Specular Only"/>
			<figcaption>Only Specular</figcaption>
		</td>
		<td>
			<img src="phong_total.png" width="400px" alt="All Combined"/>
			<figcaption>All Combined</figcaption>
		</td>
	</tr>
</table> -->

		<br><br>

		<i>Show a screenshot of your texture mapping shader using your own custom texture by modifying the textures in /textures/.</i>
<br><br>
<div style="display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; margin-top: 20px;">
  <div style="text-align: center;">
    <img src="sphere_texture.jpg" width="400px" alt="Image 1"/>
    <figcaption>Custom Texture Sphere</figcaption>
  </div>
  <div style="text-align: center;">
    <img src="cloth_texture.jpg" width="400px" alt="Image 2"/>
    <figcaption>Custom Texture After</figcaption>
  </div>
</div>
		<br><br>
		<i>Show a screenshot of bump mapping on the cloth and on the sphere. Show a screenshot of displacement mapping on the sphere. Use the same texture for both renders. You can either provide your own texture or use one of the ones in the textures directory, BUT choose one that’s not the default texture_2.png. Compare the two approaches and resulting renders in your own words. Compare how your the two shaders react to the sphere by changing the sphere mesh’s coarseness by using -o 16 -a 16 and then -o 128 -a 128.</i>
<br><br>
Below is a table displaying the changes in appearance of the sphere when using Displacement or Bump Mapping. For bump mapping, we used a normal of <code>2</code> and a height of <code>1</code>. For displacement, we used a normal of <code>100</code> and a height of <code>0.02</code>. <br><br>
With increased mesh coarseness, we see a noticeable difference in Displacement mapping whereas there is not noticeable difference for Bump mapping. Specifically, the outskirts of the sphere are shown as more rough when we increase the mesh coarseness for Displacement mapping(lower-left).
<br><br>
The reason behind this is that Bump mapping only gives us the illusion of detail on an object by only modifying it normal vectors. However, in displacement mapping we are modifying the position of the vertices
along with the normals. This change allows Displacement mapping to closely reflect the true details of a given texture especially when we get to work with coarser meshes(e.g. -o 128 -a 128). 

<div style="display: flex; flex-direction: column; align-items: center; margin-top: 20px;">
	<table style="border-collapse: separate; border-spacing: 15px; text-align: center; width: 100%;">
		<tr>
			<th style="padding: 10px; font-size: 16px; width: 45%;">Displacement</th>
			<th style="padding: 10px; font-size: 16px; width: 45%;">Bump</th>
		</tr>
		<tr>
			<td style="padding: 10px;">
				<img src="dis_o16.png" width="90%" alt="Displacement A"/><br>
				<figcaption>Displacement (-o 16 -a 16)</figcaption>
			</td>
			<td style="padding: 10px;">
				<img src="bump_o16.png" width="90%" alt="Bump A"/><br>
				<figcaption>Bump (-o 16 -a 16)</figcaption>
			</td>
		</tr>
		<tr>
			<td style="padding: 10px;">
				<img src="dis_o128.png" width="90%" alt="Displacement B"/><br>
				<figcaption>Displacement (-o 128 -a 128)</figcaption>
			</td>
			<td style="padding: 10px;">
				<img src="bump_o128.png" width="90%" alt="Bump B"/><br>
				<figcaption>Bump (-o 128 -a 128)</figcaption>
			</td></figcaption>
			</td>
		</tr>
	</table>
</div>


		<br><br>
		<i>Show a screenshot of your mirror shader on the cloth and on the sphere.</i> 
<br><br>
<table style="width: 100%; text-align: center; border-collapse: separate; border-spacing: 15px;">
    <tr>
        <th style="padding: 1px;">Sphere Only</th>
        <th style="padding: 1px;">Cloth on Sphere</th>
    </tr>
    <tr>
        <td style="padding: 10px;">
            <img src="mirror_before.png" width="300px" alt="Sphere Only"/>
        </td>
        <td style="padding: 10px;">
            <img src="mirror_after.png" width="290px" alt="Cloth on Sphere"/>
        </td>
    </tr>
</table>
		<!-- <br><br>
		<i>Explain what you did in your custom shader, if you made one.</i> -->

		<h2>(Optional) Part 6: Extra Credit - Additional cloth simulation features!</h2>
		<ul>
			<b>1. Dynamic Wind feature</b>
			<br><br>
			We included a wind feature by adding a new force to all our point masses in Part 2. To give it a dynamic effect,
			we made this a spatially varying force by changing the amount of force added to a point mass depending on the total simulation steps and it's current x,y,z position.
			Specifically, we created a <code>spatial_coeff = pm.position.x*0.3 + pm.position.y*0.2+pm.position.z*0.4.</code> along with <code>total_simulation_steps</code>, which is a new
			static variable that accumulates <code>delta_t</code>. We then create a new force <code>wind=Vector3D(0.8*total_simulation_steps+spatial_coeff, 0.2*sin(total_simulation_steps+spatial_coeff), 0.2*cos(total_simulation_steps+spatial_coeff)</code>.
			Essentially, we varied the amount of force added according to the position and current time and put cos or sin to give a rhythmical feel.
<br><br>
<img src="dynamic_wind_fast.gif" alt="A looping cloth simulation" width="500px" />
<br>

		</ul>
		
		</div>
	</body>
</html>