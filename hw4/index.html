<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 4 Write-Up</h1>
		<div style="text-align: center;">Names: Annabel Ng (3038330323) and Henry Ko (3034941989)</div>

		<br>

		Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-totoro-page/hw4/index.html">cal-cs184-student.github.io/hw-webpages-totoro-page/hw4</a>

		<br>

		Link to GitHub repository: <a href="https://github.com/cal-cs184-student/sp25-hw4-totoro-4">github.com/cal-cs184-student/sp25-hw4-totoro-4/</a>

		<figure>
			<img src="sphere_drape.gif" alt="Cloth draped over sphere" style="width:20%"/>
			<figcaption>The star cloth wireframe of this homework!</figcaption>
		</figure>

		<!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Part 1: Masses and springs</h2>
		We built out our grid of masses and springs to create our cloth wireframe. 

		<br><br>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="t1_all.png" width="400px"/>
				  <figcaption>View of wireframe with all constraints</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="task1_springs.png" width="400px"/>
				  <figcaption>Another view of wireframe with all constraints</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="t1_no_shearing.png" width="400px"/>
				  <figcaption>Wireframe with NO shearing constraints</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="t1_only_shearing.png" width="400px"/>
				  <figcaption>Wireframe with ONLY shearing constraitns</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h2>Part 2: Simulation via numerical integration</h2>
		<i>Experiment with some the parameters in the simulation. To do so, pause the simulation at the start with P, modify the values of interest, and then resume by pressing P again. You can also restart the simulation at any time from the cloth’s starting position by pressing R.</i>

		<br><br>

		<i>Describe the effects of:</i>
		<li><i>Changing the spring constant <code>ks</code>; how does the cloth behave from start to rest with a very low <code>ks</code>? A high <code>ks</code>?</i> <br><br>When there's a very low <code>ks=500</code>, the cloth seems a lot more soft and flexible with a deeper drape and it has more motion as it's falling as well. When there's a very high <code>ks=50000</code>, the cloth seems extremely stiff and barely creases in on itself and has a very small drape as well. It just seems to be made of a much thicker material that doesn't fold as easily.  </li>

		<br>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
				<tr>
					<th>ks = 500</th>
					<th>ks = 500</th>
					<th>ks = 50000</th>
					<th>ks = 50000</th>
				</tr>
				<tr>
					<td>
						<img src="ks_500_mid.png" width="200px" alt="ks 500 mid"/>
						<figcaption>Mid-fall</figcaption>
					</td>
					<td>
						<img src="ks_500.png" width="200px" alt="ks 500"/>
						<figcaption>Resting state</figcaption>
					</td>
					<td>
						<img src="ks_50000_mid.png" width="200px" alt="ks 50000 mid"/>
						<figcaption>Mid-fall</figcaption>
					</td>
					<td>
						<img src="ks_50000.png" width="200px" alt="ks 50000"/>
						<figcaption>Resting state</figcaption>
					</td>
				</tr>
			</table>
		</div>
<br><br>
		<li><i>What about for <code>density</code>?</i> 
			<br><br>
			When the density is low(density=1), the cloth gives the impression that its light-weight as it's seen be being less droopy in its resting state.
			However, when the density is set to a high value(density=10,000), the cloth feels heavy as it can be seen with a large droop in its final resting state.
			<br>
			<br></li>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
				<tr>
					<th>density = 1</th>
					<th>density = 1</th>
					<th>density = 10,000</th>
					<th>density = 10,000</th>
				</tr>
				<tr>
					<td>
						<img src="density=1_init.png" width="200px" alt="density 1 mid"/>
						<figcaption>Mid-fall</figcaption>
					</td>
					<td>
						<img src="density=1_final.png" width="200px" alt="density 1 final"/>
						<figcaption>Resting state</figcaption>
					</td>
					<td>
						<img src="density=10000_init.png" width="200px" alt="density 10000 mid"/>
						<figcaption>Mid-fall</figcaption>
					</td>
					<td>
						<img src="density=10000_final.png" width="200px" alt="density 10000 final"/>
						<figcaption>Resting state</figcaption>
					</td>
				</tr>
			</table>
		</div>
<br><br>
		<li><i>What about for <code>damping</code>?</i>
		<br><br> When the damping percentage is low(0.10), the cloth drops quickly with little resistance, but when 
		the damping percentage is high(0.90), the cloth falls slowly and gradually.
		<br><br>
	</li>
	<div style="display: flex; flex-direction: column; align-items: center;">
		<table style="width: 100%; text-align: center; border-collapse: collapse;">
			<tr>
				<th>damping = 0.10</th>
				<th>damping = 0.10</th>
				<th>damping = 0.90</th>
				<th>damping = 0.90</th>
			</tr>
			<tr>
				<td>
					<img src="damping=0.10_init.png" width="200px" alt="damping .10 mid"/>
					<figcaption>Mid-fall</figcaption>
				</td>
				<td>
					<img src="damping=0.10_final.png" width="200px" alt="damping .10 final"/>
					<figcaption>Resting state</figcaption>
				</td>
				<td>
					<img src="damping=0.90_init.png" width="200px" alt="damping .90 mid"/>
					<figcaption>Mid-fall</figcaption>
				</td>
				<td>
					<img src="damping=0.90_final.png" width="200px" alt="damping .90 final"/>
					<figcaption>Resting state</figcaption>
				</td>
			</tr>
		</table>
	</div>
	
		
		<li><i>For each of the above, observe any noticeable differences in the cloth compared to the default parameters and show us some screenshots of those interesting differences and describe when they occur.</i></li>
		<ul>1. Spring Constant(ks)</ul>
		Compared to the default state, there's a noticeable difference when theres a very high spring constant. For example, below is a comparison between default(ks=5,000) and a high spring constant(ks=50,000).
		We can see that the cloth looks noticeably more stiff with a high spring constant. 
		<br><br>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
				<tr>
					<td>
						<img src="resting_cloth.png" width=60% alt="damping .10 mid"/>
						<figcaption>ks = 5,000 (default)</figcaption>
					</td>
					<td>
						<img src="ks_50000.png" width=75% alt="damping .10 final"/>
						<figcaption>ks = 50,000</figcaption>
					</td>
				</tr>
			</table>
		</div>
<br>
<ul>2. Density</ul>
For density, we can see a noticeable difference in the perceived weight of a cloth when density is high. 
Compared to the default value of density of 15, when there's a density of 10,000 the final resting state of the cloth looks heavy. 
<br><br>
<div style="display: flex; flex-direction: column; align-items: center;">
	<table style="width: 100%; text-align: center; border-collapse: collapse;">
		<tr>
			<td>
				<img src="resting_cloth.png" width=60% alt="damping .10 mid"/>
				<figcaption>density = 15 (default)</figcaption>
			</td>
			<td>
				<img src="density=10000_final.png" width=90% alt="damping .10 final"/>
				<figcaption>density = 10,000</figcaption>
			</td>
		</tr>
	</table>
</div>
<br>
<ul>3. Damping</ul>
The visual differences between final states of different damping values are hard to tell, but the difference lies in
how fast the cloth reaches the final resting state. The higher damping percentage is, the longer it takes for it to reach its resting state. 
<br><br>
<div style="display: flex; flex-direction: column; align-items: center;">
	<table style="width: 100%; text-align: center; border-collapse: collapse;">
		<tr>
			<td>
				<img src="resting_cloth.png" width=60% alt="damping .10 mid"/>
				<figcaption>damping = 0.20 (default)</figcaption>
			</td>
			<td>
				<img src="damping=0.90_final.png" width=90% alt="damping .10 final"/>
				<figcaption>damping = 0.90</figcaption>
			</td>
		</tr>
	</table>
</div>

		<br><br>

		<i>Show us a screenshot of your shaded cloth from scene/pinned4.json in its final resting state! If you choose to use different parameters than the default ones, please list them.</i>
		<br><br>
		<div style="text-align: center;">
			<img src="resting_cloth.png" width="70%" alt="Pinned cloth resting state with default parameters"/>
			<figcaption>Pinned cloth resting state with default parameters</figcaption>
		</div>


		<h2>Part 3: Handling collisions with other objects</h2>
		<i>Describe your implementation of handling collisions with spheres and planes.</i>
		<br><br>
		For handling collisions with spheres, we code up the <code>Sphere:Collide</code> function to first calculate the distance between the given <code>PointMass</code> position and the sphere's center by subtracting the sphere's center from the <code>PointMass</code> position and taking the norm as the distance. If the computed distance is less than the sphere's radius, this indicates that the <code>PointMass</code> lies inside the sphere's radius. Since we only care about the <code>PointMass</code> that lie inside the sphere's radius, we then compute the tangent point on the surface of the sphere by adding the unit direction between the sphere and the <code>PointMass</code> scaled by the size of the radius.  Once we have this tangent point, we calculate the correction vector as the difference between this tangent point and the last position of the <code>PointMass</code>. We then apply this correction vector to the <code>PointMass</code> position by setting the position to be the last position plus the correction vector multiplied by <code>(1-friction)</code> to account for the friction of the collision, essentially bumping up the position of the <code>PointMass</code> up to the surface of the sphere. 

		<br><br>

		For handling collisions with planes, we code up the <code>Plane:Collide</code> function to check if the <code>PointMass</code> is below the plane's height by taking the difference between the <code>PointMass</code>'s position and the plane's given point, and checking if the dot product of this difference with the plane's normal is less than the <code>SURFACE_OFFSET</code>. If it's less than the offset, this indicates that the <code>PointMass</code> is below the plane's height and we need to adjust it. To do this correction, we compute the tangent point on the plane by subtracting the normal direction of the plane, scaled by the distance to the plane adjusted by the offset, from the <code>PointMass</code>'s position. Similar to the sphere collision, we calculate the correction vector as the difference between the tangent point and the <code>PointMass</code>'s last position. We then apply this correction vector to the <code>PointMass</code> position by setting the position to be the last position plus the correction vector multiplied by <code>(1-friction)</code> to account for friction of the collision.
		<br><br>
		
		In addition, we also modify the <code>Cloth::Collide</code> code to iterate through all the <code>PointMass</code> object, and in each iteration, we iterate through every <code>CollisionObject</code> and check for collisions with the <code>PointMass</code> object.

		<br><br>
		<i>Show us screenshots of your shaded cloth from scene/sphere.json in its final resting state on the sphere using the default ks = 5000 as well as with ks = 500 and ks = 50000. Describe the differences in the results.</i>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
				<tr>
					<td>
						<img src="sphere_500.png" width=90% alt="Sphere ks 500"/>
						<figcaption>ks = 500</figcaption>
					</td>
					<td>
						<img src="sphere_5000.png" width=90% alt="Sphere ks 5000"/>
						<figcaption>ks = 5000</figcaption>
					</td>
					<td>
						<img src="sphere_50000.png" width=90% alt="Sphere ks 50000"/>
						<figcaption>ks = 50000</figcaption>
					</td>
				</tr>
			</table>
		</div>

		<br>
		As the ks increases, the cloth seems to be much more stiff and rigid and less likely to drape softly over the sphere. The cloth with <code>ks = 500</code> is much more flexible and drapes over the sphere more naturally and molds over the sphere, while the cloth with <code>ks = 50000</code> is very stiff and doesn't mold to the sphere's shape as much and appears to extrude out more. 

		<br><br>

		<i>Show us a screenshot of your shaded cloth lying peacefully at rest on the plane.</i>


		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
				<tr>
					<td>
						<img src="plane.png" width=80% alt="Sphere ks 500"/>
						<figcaption>Cloth at rest on plane</figcaption>
					</td>
					<td>
						<img src="plane_wire.png" width=80% alt="Sphere ks 5000"/>
						<figcaption>Zoom of cloth wireframe at rest on plane</figcaption>
					</td>
				</tr>
			</table>
		</div>

		<h2>Part 4: Handling self-collisions</h2>
		<i>Describe your implementation of handling self-collisions.</i>
		<br><br>
		To handle self-collision, we first write a helper function <code>Cloth::hash_position</code> which hashes a given 3D position into a unique float based on membership in a 3D boxes with dimensions <code>w = 3 * width / num_width_points</code>, <code>h = 3 * height / num_height_points</code>, and <code>t = std::max(w, h)</code>. We then "snap" the pointmass to the nearest box by taking the <code>fmod</code> of the position's x, y, and z coordinates with respect to the box dimensions and subtracting the <code>fmod</code> value from the position coordinate to get the box coordinates. We then combine these box coordinates into a unique float hash value by setting the <code>hash = snapped_x + width * (snapped_y + height * snapped_z)</code>

		<br><br>

		Next, we wrote a function to actually build the spatial map out of all the point masses by iterating through each point mass, computing the hash based on the point mass position, checking if the hash is already in the spatial map, and if not, adding it to the spatial map. 
		<br><br>

		Then, we wrote the <code>Cloth::self_collide</code> function to iterate through all the point masses, check for collisions with other point masses in the same spatial map cell, and determine the average correction amount. We first calculate the hash of that position and check if there are any other point masses in the same cell. We initialize a <code>total_correction</code> vector and a corrections counter, and iterate through each candidate point mass and check if the candidate is not the same as the current point mass. If they are not the same, we calculate the distance <code>dist</code> between the given point mass and the candidate by subtracting their positions and taking the norm. If the distance apart is less than <code>2*thickness</code>, we want to find the correction vector necessary to set the pairwise distance to be <b>equal</b> to <code>2*thickness</code> apart. We do this by taking the unit direction between the two point masses, and scaling this direction by <code>2*thickness - dist</code>, which becomes our <code>curr_correction</code> vector. We then add this correction vector to our <code>total_correction</code> vector and increment our corrections counter. After iterating through all the candidates, we  check if there are any corrections, and if there are, we divide the <code>total_correction</code> vector by the corrections counter and simulation steps and apply this average correction to the current point mass's position by incrementing the position by the average correction vector.
		
		
		<br><br>
		Lastly, we modified the <code>PointMass::Collide</code> function to check for self-collisions by building the spatial map, and then iterating through the all of the point masses and calling <code>self_collide</code> to check for self collision. 

		<br><br>
		<i>Show us at least 3 screenshots that document how your cloth falls and folds on itself, starting with an early, initial self-collision and ending with the cloth at a more restful state (even if it is still slightly bouncy on the ground).</i>
		<br><br>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
				<tr>
					<td style="width: 25%; padding-right: 10px;">
						<img src="self_1.png" width="100%" alt="Initial Self-Collision" style="object-fit: cover; height: 200px;"/>
						<figcaption>Initial Self-Collision</figcaption>
					</td>
					<td style="width: 25%; padding-right: 10px;">
						<img src="self_2.png" width="100%" alt="Intermediate State" style="object-fit: cover; height: 200px;"/>
						<figcaption>Intermediate State</figcaption>
					</td>
					<td style="width: 25%; padding-right: 10px;">
						<img src="self_3.png" width="100%" alt="Further Folding" style="object-fit: cover; height: 200px;"/>
						<figcaption>Further Folding</figcaption>
					</td>
					<td style="width: 25%;">
						<img src="self_4.png" width="100%" alt="Resting State" style="object-fit: cover; height: 200px;"/>
						<figcaption>Resting State</figcaption>
					</td>
				</tr>
			</table>
		</div>

		<br><br>
		<i>Vary the density as well as ks and describe with words and screenshots how they affect the behavior of the cloth as it falls on itself.</i>
<br><br>
On a high level, density controls how fast the cloth falls along with how many small creases there are. A more dense cloth will fall faster and will yield a higher number
of smaller folds(i.e. higher tendency of self collisions). Meanwhile, ks will control how stiff the cloth is to folding. A higher ks value will result the cloth
resisting to having many folds.
<br><br>
Below is a chart of varying density and ks. We can see that a low density and low ks(lower-left) results in a light-weight cloth that folds well. But if we 
increase the ks value to 9,000(upper-left), we can see the cloth is "resisting" folds, hence resulting in only a few large folds.
On the other side of the spectrum we can see that a high density and high ks(upper-right), will result in a cloth that is heavy(i.e. falling fast) and more rigid.

<div style="display: flex; flex-direction: column; align-items: center;">
	<table style="border-collapse: separate; text-align: center; border-spacing: 10px">
		<tr>
			<td rowspan="4" style="writing-mode: vertical-rl; transform: rotate(180deg); padding: 10px; font-weight: bold;">Increasing ks →</td>
			<td></td>
			<td style="padding: 5px; font-weight: bold;">density = 1</td>
			<td style="padding: 5px; font-weight: bold;">density = 15</td>
			<td style="padding: 5px; font-weight: bold;">density = 50</td>
		</tr>
		<tr>
			<td style="font-weight: bold;">ks = 9,000</td>
			<td>
				<img src="d1_ks9000.png" width="200px" alt="density 1 ks 9000"/>
				<figcaption>density=1, ks=9,000</figcaption>
			</td>
			<td>
				<img src="d15_ks9000.png" width="200px" alt="density 15 ks 9000"/>
				<figcaption>density=15, ks=9,000</figcaption>
			</td>
			<td>
				<img src="d50_ks9000.png" width="200px" alt="density 50 ks 9000"/>
				<figcaption>density=50, ks=9,000</figcaption>
			</td>
		</tr>
		<tr>
			<td style="font-weight: bold;">ks = 5,000</td>
			<td>
				<img src="d1_ks5000.png" width="200px" alt="density 1 ks 5000"/>
				<figcaption>density=1, ks=5,000</figcaption>
			</td>
			<td>
				<img src="d15_ks5000.png" width="200px" alt="density 15 ks 5000"/>
				<figcaption>density=15, ks=5,000</figcaption>
			</td>
			<td>
				<img src="d50_ks5000.png" width="200px" alt="density 50 ks 5000"/>
				<figcaption>density=50, ks=5,000</figcaption>
			</td>
		</tr>
		<tr>
			<td style="font-weight: bold;">ks = 1,000</td>
			<td>
				<img src="d1_ks1000.png" width="200px" alt="density 1 ks 1000"/>
				<figcaption>density=1, ks=1,000</figcaption>
			</td>
			<td>
				<img src="d15_ks1000.png" width="200px" alt="density 15 ks 1000"/>
				<figcaption>density=15, ks=1,000</figcaption>
			</td>
			<td>
				<img src="d50_ks1000.png" width="200px" alt="density 50 ks 1000"/>
				<figcaption>density=50, ks=1,000</figcaption>
			</td>
		</tr>
	</table>
</div>



		<h2>Part 5: Shaders</h2>
		<i>Explain in your own words what is a shader program and how vertex and fragment shaders work together to create lighting and material effects.</i>
<br><br>
A shader program is a specialized program made to run on the GPU in parallel. The main purpose is to compute how geometry is rendered on the screen quickly.
There are two parts to a shader--the vertex shader and fragment shader. The vertex shader transforms the 3D positions of each vertex on the mesh from model space
into screen space using transformation matrices. It also passes information like normals or positions as output. The outputs of the vertex shader are used as
inputs to the fragment shader where it runs for each pixel that is part of the final rendered triangle. It is reponsible for getting the right
lighting, color, and texture, which is why its result is "out_color" that determines the final color on our screen.

		<br><br>

		<i>Explain the Blinn-Phong shading model in your own words. Show a screenshot of your Blinn-Phong shader outputting only the ambient component, a screen shot only outputting the diffuse component, a screen shot only outputting the specular component, and one using the entire Blinn-Phong model.</i>
<br><br>
The Blinn-Phong shading model combines ambient light component, diffuse light component, and specular light component to get the final light or color value. The ambient light can be seen
as the default level of light there is and is set to a small constant value. We used a ambient light value of 0.1 to ensure that it's not zero, but very small so that it does not
interfere too much with diffuse light and specular light. Next, diffuse light is essentially how much light hits the surface since it's the dot product between the normal vector to the surface
and light direction. This means that diffuse light is strongest when the light source is directly facing the surface. Finally, the specular light component is responsible for determining how "shiny"
the surface is, such as a metallic surface. And together, all-combined, we get the final Blinn-Phong shading model.
<br>
<div style="display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; margin-top: 20px;">
  <div style="text-align: center;">
    <img src="phong_ambient_only.png" width="400px" alt="Image 1"/>
    <figcaption>Only Ambient</figcaption>
  </div>
  <div style="text-align: center;">
    <img src="phong_diffuse_only.png" width="400px" alt="Image 2"/>
    <figcaption>Only Diffuse</figcaption>
  </div>
  <div style="text-align: center;">
    <img src="phong_specular_only.png" width="400px" alt="Image 3"/>
    <figcaption>Only Specular</figcaption>
  </div>
  <div style="text-align: center;">
    <img src="phong_total.png" width="400px" alt="Image 4"/>
    <figcaption>All Combined</figcaption>
  </div>
</div>

		<br><br>

		<i>Show a screenshot of your texture mapping shader using your own custom texture by modifying the textures in /textures/.</i>
<br><br>
<div style="display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; margin-top: 20px;">
  <div style="text-align: center;">
    <img src="custom_texture_me.png" width="400px" alt="Image 1"/>
    <figcaption>Custom Texture Sphere</figcaption>
  </div>
  <div style="text-align: center;">
    <img src="custom_texture_me_after.png" width="400px" alt="Image 2"/>
    <figcaption>Custom Texture After</figcaption>
  </div>
</div>
		<br><br>
		<i>Show a screenshot of bump mapping on the cloth and on the sphere. Show a screenshot of displacement mapping on the sphere. Use the same texture for both renders. You can either provide your own texture or use one of the ones in the textures directory, BUT choose one that’s not the default texture_2.png. Compare the two approaches and resulting renders in your own words. Compare how your the two shaders react to the sphere by changing the sphere mesh’s coarseness by using -o 16 -a 16 and then -o 128 -a 128.</i>
<br><br>
Below is a table displaying the changes in appearance of the sphere when using Displacement or Bump Mapping. With increased mesh coarseness, we
see a noticeable difference in Displacement mapping whereas there is not noticeable difference for Bump mapping. Specifically, the outskirts of the sphere are shown
as more rough when we increase the mesh coarseness for Displacement mapping(lower-left).
<br><br>
The reason behind this is that Bump mapping only gives us the illusion of detail on an object by only modifying it normal vectors. However, in displacement mapping we are modifying the position of the vertices
along with the normals. This change allows Displacement mapping to closely reflect the true details of a given texture especially when we get to work with coarser meshes(e.g. -o 128 -a 128). 

<div style="display: flex; flex-direction: column; align-items: center; margin-top: 20px;">
  <table style="border-collapse: collapse; text-align: center;">
    <tr>
      <th></th>
      <th style="padding: 10px; font-size: 16px;">Displacement</th>
      <th style="padding: 10px; font-size: 16px;">Bump</th>
    </tr>
    <tr>
      <td style="font-weight: bold;">-o 16 -a 16</td>
      <td>
        <img src="dis_o16.png" width="400px" alt="Displacement A"/><br>
        <figcaption>Displacement (16)</figcaption>
      </td>
      <td>
        <img src="bump_o16.png" width="400px" alt="Bump A"/><br>
        <figcaption>Bump (16)</figcaption>
      </td>
    </tr>
    <tr>
      <td style="font-weight: bold;">-o 128 -a 128</td>
      <td>
        <img src="dis_o128.png" width="400px" alt="Displacement B"/><br>
        <figcaption>Displacement (128)</figcaption>
      </td>
      <td>
        <img src="bump_o128.png" width="400px" alt="Bump B"/><br>
        <figcaption>Bump (128)</figcaption>
      </td>
    </tr>
  </table>
</div>


		<br><br>
		<i>Show a screenshot of your mirror shader on the cloth and on the sphere.</i> 
<br><br>
<div style="display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; margin-top: 20px;">
  <div style="text-align: center;">
    <img src="mirror_before.png" width="400px" alt="Image 1"/>
    <figcaption>Sphere Only</figcaption>
  </div>
  <div style="text-align: center;">
    <img src="mirror_after.png" width="400px" alt="Image 2"/>
    <figcaption>Cloth on Sphere</figcaption>
  </div>
</div>
		<br><br>
		<i>Explain what you did in your custom shader, if you made one.</i> 

		<h2>(Optional) Part 6: Extra Credit - Additional cloth simulation features!</h2>
		TODO
		
		</div>
	</body>
</html>